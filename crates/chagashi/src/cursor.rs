use std::{fmt::Display, sync::atomic::AtomicUsize, time::Duration};

use matcha::*;

struct Timeout(usize);

#[derive(Debug)]
/// A blinking cursor model used by input components.
///
/// This model renders the character under the cursor and toggles inverse video while blinking.
pub struct Cursor {
    /// The ID of this Cursor as it relates to other cursors
    id: usize,
    /// Cursor Blink state.
    blink: bool,
    /// Cursor blink interval.
    blink_speed: Duration,
    /// The ID of the blink message we're expecting to receive.
    blink_tag: usize,
    /// focus indicates whether the containing input is focused
    focus: bool,
    /// char is the character under the cursor
    char: String,
    // mode determines the behavior of the cursor
    mode: CursorMode,
    /// text color
    text_color: Option<Color>,
    /// canceled blink tag
    canceled_tag: AtomicUsize,
}

const DEFAULT_BLINK_SPEED: Duration = Duration::from_millis(530);

impl Model for Cursor {
    #[cfg_attr(feature = "tracing", tracing::instrument(skip_all))]
    fn view(&self) -> impl Display {
        if self.blink || !self.focus {
            if let Some(color) = self.text_color {
                style(self.char.to_string()).with(color).to_string()
            } else {
                self.char.to_string()
            }
        } else {
            style(self.char.to_string()).negative().to_string()
        }
    }

    #[cfg_attr(feature = "tracing", tracing::instrument(skip_all))]
    fn update(self, msg: &Msg) -> (Self, Option<Cmd>) {
        if msg.downcast_ref::<InitialBlinkMsg>().is_some() {
            // We accept all initialBlinkMsgs generated by the Blink command.
            // NOP if not blink mode of not focused.
            if self.mode != CursorMode::Blink || !self.focus {
                return (self, None);
            }
            return self.blink_cmd();
        }

        if let Some(msg) = msg.downcast_ref::<BlinkMsg>() {
            // We're choosy about whether to accept blinkMsgs so that our cursor
            // only exactly when it should.
            // Is this model blink-able?
            if self.mode != CursorMode::Blink || !self.focus {
                return (self, None);
            }

            let canceled_tag = self.canceled_tag.load(std::sync::atomic::Ordering::Relaxed);
            // Were we expecting this blink message?
            if msg.id != self.id || msg.tag <= canceled_tag {
                return (self, None);
            }

            if self.mode == CursorMode::Blink {
                let blink = !self.blink;
                let new_self = Self { blink, ..self };
                let (new, cmd) = new_self.blink_cmd();
                return (
                    Self {
                        blink_tag: new.blink_tag + 1,
                        ..new
                    },
                    cmd,
                );
            }
        }

        if msg.downcast_ref::<BlinkCanceled>().is_some() {
            // NOP
            return (self, None);
        }

        (self, None)
    }
}

/// A message used to initialize cursor blinking.
///
/// This is typically scheduled by [`Cursor::set_mode`] when switching to blink mode.
pub fn blink() -> Msg {
    Box::new(InitialBlinkMsg)
}

impl Default for Cursor {
    fn default() -> Self {
        Self {
            id: 0,
            blink: false,
            blink_speed: DEFAULT_BLINK_SPEED,
            blink_tag: 0,
            focus: false,
            char: " ".to_string(),
            mode: CursorMode::Blink,
            text_color: None,
            canceled_tag: AtomicUsize::new(0),
        }
    }
}

impl Cursor {
    /// Create a new cursor with default settings.
    pub fn new() -> Self {
        Self::default()
    }

    /// Blur blurs the cursor.
    #[cfg_attr(feature = "tracing", tracing::instrument(skip_all))]
    pub fn blur(self) -> Self {
        Self {
            focus: false,
            blink: true,
            ..self
        }
    }

    /// set_char sets the character under the cursor.
    #[cfg_attr(feature = "tracing", tracing::instrument(skip_all))]
    pub fn set_char(self, c: impl Into<String>) -> Self {
        Self {
            char: c.into(),
            ..self
        }
    }

    /// set_text_color sets the character color under the cursor.
    #[cfg_attr(feature = "tracing", tracing::instrument(skip_all))]
    pub fn set_text_color(self, c: Color) -> Self {
        Self {
            text_color: Some(c),
            ..self
        }
    }

    /// set_blink sets the cursor blink state.
    #[cfg_attr(feature = "tracing", tracing::instrument(skip_all))]
    pub fn set_blink(self, v: bool) -> Self {
        Self { blink: v, ..self }
    }

    /// reset_text_color sets the character color under the cursor.
    #[cfg_attr(feature = "tracing", tracing::instrument(skip_all))]
    pub fn reset_text_color(self) -> Self {
        Self {
            text_color: None,
            ..self
        }
    }

    /// blink_cmd is an command used to manage cursor blinking.
    #[cfg_attr(feature = "tracing", tracing::instrument(skip_all))]
    pub fn blink_cmd(self) -> (Self, Option<Cmd>) {
        if self.mode != CursorMode::Blink {
            return (self, None);
        }

        let (sender, receiver) = std::sync::mpsc::channel::<Timeout>();

        let dur = self.blink_speed;
        let old_tag = self.blink_tag;
        let tag = self.blink_tag + 1;
        let id = self.id;

        std::thread::spawn(move || {
            std::thread::sleep(dur);
            let canceled_tag = self.canceled_tag.load(std::sync::atomic::Ordering::Relaxed);
            if tag <= canceled_tag {
                return;
            }
            let _ = sender.send(Timeout(tag));
        });

        (
            Self {
                blink_tag: tag,
                canceled_tag: AtomicUsize::new(old_tag),
                ..self
            },
            Some(Cmd::sync(Box::new(move || {
                if let Ok(Timeout(tag)) = receiver.recv() {
                    return Box::new(BlinkMsg { id, tag });
                }
                Box::new(BlinkCanceled)
            }))),
        )
    }

    /// Focus focuses the cursor to allow it to blink if desired.
    #[cfg_attr(feature = "tracing", tracing::instrument(skip_all))]
    pub fn focus(self) -> (Self, Option<Cmd>) {
        // if self.mode == CursorMode::Blink && self.focus {
        let (new, cmd) = self.blink_cmd();
        (
            Self {
                focus: true,
                blink: new.mode == CursorMode::Hide,
                ..new
            },
            cmd,
        )
        // }
        // (
        //     Self {
        //         focus: true,
        //         blink: self.mode == CursorMode::Hide,
        //         ..self
        //     },
        //     cmd,
        // )
    }

    /// Mode returns the model's cursor mode. For available cursor modes, see
    /// type Mode.
    #[cfg_attr(feature = "tracing", tracing::instrument(skip_all))]
    pub fn mode(&self) -> CursorMode {
        self.mode
    }

    /// For available cursor modes, see type CursorMode.
    #[cfg_attr(feature = "tracing", tracing::instrument(skip_all))]
    pub fn set_mode(self, mode: CursorMode) -> (Self, Option<Cmd>) {
        let new_blink = self.mode == CursorMode::Hide || !self.focus;
        if mode == CursorMode::Blink {
            return (
                Self {
                    mode,
                    blink: new_blink,
                    ..self
                },
                Some(Cmd::sync(Box::new(blink))),
            );
        }
        (
            Self {
                mode,
                blink: new_blink,
                ..self
            },
            None,
        )
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, derive_more::Display)]
/// Cursor display mode.
pub enum CursorMode {
    /// Blink using inverse video.
    Blink,
    /// Always visible (no blinking).
    Static,
    /// Hidden cursor (always rendered as "not blinking").
    Hide,
}

/// initialBlinkMsg initializes cursor blinking.
struct InitialBlinkMsg;

/// BlinkCanceled is sent when a blink operation is canceled_tag.
struct BlinkCanceled;

/// BlinkMsg signals that the cursor should blink. It contains metadata that
/// allows us to tell if the blink message is the one we're expecting.
struct BlinkMsg {
    id: usize,
    tag: usize,
}
